"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tl = require("azure-pipelines-task-lib/task");
const Q = require("q");
const matchPatternForSize = new RegExp(/[\d\.]+/);
function build(connection, dockerFile, context, commandArguments, labelArguments, tagArguments, onCommandOut) {
    var command = connection.createCommand();
    command.arg("build");
    command.arg(["-f", dockerFile]);
    if (labelArguments) {
        labelArguments.forEach(label => {
            command.arg(["--label", label]);
        });
    }
    command.line(commandArguments);
    if (tagArguments) {
        tagArguments.forEach(tagArgument => {
            command.arg(["-t", tagArgument]);
        });
    }
    command.arg(context);
    // setup variable to store the command output
    let output = "";
    command.on("stdout", data => {
        output += data;
    });
    return connection.execCommand(command).then(() => {
        // Return the std output of the command by calling the delegate
        onCommandOut(output);
    });
}
exports.build = build;
function command(connection, dockerCommand, commandArguments, onCommandOut) {
    let command = connection.createCommand();
    command.arg(dockerCommand);
    command.line(commandArguments);
    // setup variable to store the command output
    let output = "";
    command.on("stdout", data => {
        output += data;
    });
    return connection.execCommand(command).then(() => {
        // Return the std output of the command by calling the delegate
        onCommandOut(output);
    });
}
exports.command = command;
function push(connection, image, commandArguments, onCommandOut) {
    var command = connection.createCommand();
    command.arg("push");
    command.arg(image);
    command.line(commandArguments);
    // setup variable to store the command output
    let output = "";
    command.on("stdout", data => {
        output += data;
    });
    return connection.execCommand(command).then(() => {
        // Return the std output of the command by calling the delegate
        onCommandOut(image, output + "\n");
    });
}
exports.push = push;
function getCommandArguments(args) {
    return args ? args.replace(/\n/g, " ") : "";
}
exports.getCommandArguments = getCommandArguments;
function getLayers(connection, imageId) {
    return __awaiter(this, void 0, void 0, function* () {
        var layers = [];
        var history = yield getHistory(connection, imageId);
        if (!history) {
            return null;
        }
        var lines = history.split(/[\r?\n]/);
        lines.forEach(line => {
            line = line.trim();
            if (line.length != 0) {
                layers.push(parseHistory(line));
            }
        });
        return layers.reverse();
    });
}
exports.getLayers = getLayers;
function getImageSize(layers) {
    let imageSize = 0;
    for (const layer of layers) {
        for (let key in layer) {
            if (key.toLowerCase() === "size") {
                const layerSize = extractSizeInBytes(layer[key]);
                imageSize += layerSize;
            }
        }
    }
    return imageSize.toString() + "B";
}
exports.getImageSize = getImageSize;
function extractSizeInBytes(size) {
    const sizeStringValue = size.match(matchPatternForSize);
    if (sizeStringValue && sizeStringValue.length > 0) {
        const sizeIntValue = parseFloat(sizeStringValue[0]);
        const sizeUnit = size.substring(sizeIntValue.toString().length);
        switch (sizeUnit.toLowerCase()) {
            case "b": return sizeIntValue;
            case "kb": return sizeIntValue * 1024;
            case "mb": return sizeIntValue * 1024 * 1024;
            case "gb": return sizeIntValue * 1024 * 1024 * 1024;
            case "tb": return sizeIntValue * 1024 * 1024 * 1024 * 1024;
            case "pb": return sizeIntValue * 1024 * 1024 * 1024 * 1024 * 1024;
        }
    }
    return 0;
}
exports.extractSizeInBytes = extractSizeInBytes;
function parseHistory(input) {
    const NOP = '#(nop)';
    let directive = "UNSPECIFIED";
    let argument = "";
    let index = input.indexOf(NOP);
    const createdByMatch = "; createdBy:";
    const indexCreatedBy = input.indexOf(createdByMatch);
    if (index != -1) {
        argument = input.substr(index + 6).trim();
        directive = argument.substr(0, argument.indexOf(' '));
        argument = argument.substr(argument.indexOf(' ') + 1).trim();
    }
    else {
        directive = 'RUN';
        argument = input.substring(indexCreatedBy + createdByMatch.length, input.length - 1);
    }
    let createdAt = "";
    let layerSize = "";
    const createdAtMatch = "createdAt:";
    const layerSizeMatch = "; layerSize:";
    const indexCreatedAt = input.indexOf(createdAtMatch);
    const indexLayerSize = input.indexOf(layerSizeMatch);
    if (indexCreatedAt >= 0 && indexLayerSize >= 0) {
        createdAt = input.substring(indexCreatedAt + createdAtMatch.length, indexLayerSize);
        layerSize = input.substring(indexLayerSize + layerSizeMatch.length, indexCreatedBy);
    }
    return { "directive": directive, "arguments": argument, "createdOn": createdAt, "size": layerSize };
}
function getHistory(connection, image) {
    return __awaiter(this, void 0, void 0, function* () {
        var command = connection.createCommand();
        command.arg("history");
        command.arg(["--format", "createdAt:{{.CreatedAt}}; layerSize:{{.Size}}; createdBy:{{.CreatedBy}}"]);
        command.arg("--no-trunc");
        command.arg(image);
        const defer = Q.defer();
        // setup variable to store the command output
        let output = "";
        command.on("stdout", data => {
            output += data;
        });
        try {
            connection.execCommand(command).then(() => {
                defer.resolve();
            });
        }
        catch (e) {
            // Swallow any exceptions encountered in executing command
            // such as --format flag not supported in old docker cli versions
            output = null;
            defer.resolve();
            tl.warning("Not publishing to image meta data store as get history failed with error " + e);
        }
        yield defer.promise;
        return output;
    });
}
