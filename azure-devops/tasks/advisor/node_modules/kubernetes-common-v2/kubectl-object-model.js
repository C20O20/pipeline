"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tl = require("azure-pipelines-task-lib/task");
class Kubectl {
    constructor(kubectlPath, namespace, ignoreSSLErrors) {
        this.kubectlPath = kubectlPath;
        this.ignoreSSLErrors = !!ignoreSSLErrors;
        if (!!namespace) {
            this.namespace = namespace;
        }
        else {
            this.namespace = 'default';
        }
    }
    apply(configurationPaths) {
        const command = tl.tool(this.kubectlPath);
        command.arg('apply');
        command.arg(['-f', this.createInlineArray(configurationPaths)]);
        return this.execute(command);
    }
    annotate(resourceType, resourceName, annotations, overwrite) {
        const command = tl.tool(this.kubectlPath);
        command.arg('annotate');
        command.arg([resourceType, resourceName]);
        command.arg(annotations);
        if (!!overwrite) {
            command.arg(`--overwrite`);
        }
        return this.execute(command);
    }
    annotateFiles(files, annotations, overwrite) {
        const command = tl.tool(this.kubectlPath);
        command.arg('annotate');
        command.arg(['-f', this.createInlineArray(files)]);
        command.arg(annotations);
        if (!!overwrite) {
            command.arg(`--overwrite`);
        }
        return this.execute(command);
    }
    createDockerSecret(secretName, registryServer, userName, password, email, force) {
        if (!!force && !!secretName) {
            this.deleteSecret(secretName);
        }
        const command = tl.tool(this.kubectlPath);
        command.arg('create');
        command.arg('secret');
        command.arg('docker-registry');
        command.arg(secretName);
        command.arg(['--docker-username', userName]);
        command.arg(['--docker-password', password]);
        command.arg(['--docker-server', registryServer]);
        command.arg(['--docker-email', email]);
        return this.execute(command);
    }
    createGenericSecret(secretName, args, force) {
        if (!!force && !!secretName) {
            this.deleteSecret(secretName);
        }
        const command = tl.tool(this.kubectlPath);
        command.arg('create');
        command.arg('secret');
        command.arg('generic');
        command.arg(secretName);
        if (args) {
            command.line(args);
        }
        return this.execute(command);
    }
    describe(resourceType, resourceName, silent) {
        const command = tl.tool(this.kubectlPath);
        command.arg('describe');
        command.arg([resourceType, resourceName]);
        return this.execute(command, silent);
    }
    getNewReplicaSet(deployment) {
        let newReplicaSet = '';
        const result = this.describe('deployment', deployment, true);
        if (result != null && result.stdout != null) {
            const stdout = result.stdout.split('\n');
            stdout.forEach((line) => {
                if (!!line && line.toLowerCase().indexOf('newreplicaset') > -1) {
                    newReplicaSet = line.substr(14).trim().split(' ')[0];
                }
            });
        }
        return newReplicaSet;
    }
    getAllPods() {
        const command = tl.tool(this.kubectlPath);
        command.arg('get');
        command.arg('pods');
        command.arg(['-o', 'json']);
        return this.execute(command, true);
    }
    checkRolloutStatus(resourceType, name) {
        const command = tl.tool(this.kubectlPath);
        command.arg(['rollout', 'status']);
        command.arg(resourceType + '/' + name);
        return this.execute(command);
    }
    getResource(resourceType, name) {
        const command = tl.tool(this.kubectlPath);
        command.arg('get');
        command.arg(resourceType + '/' + name);
        command.arg(['-o', 'json']);
        return this.execute(command);
    }
    getResources(applyOutput, filterResourceTypes) {
        const outputLines = applyOutput.split('\n');
        const results = [];
        outputLines.forEach(line => {
            const words = line.split(' ');
            if (words.length > 2) {
                const resourceType = words[0].trim();
                const resourceName = JSON.parse(words[1].trim());
                if (filterResourceTypes.filter(type => !!type && resourceType.toLowerCase().startsWith(type.toLowerCase())).length > 0) {
                    results.push({
                        type: resourceType,
                        name: resourceName
                    });
                }
            }
        });
        return results;
    }
    scale(resourceType, resourceName, replicas) {
        const command = tl.tool(this.kubectlPath);
        command.arg('scale');
        command.arg(resourceType + '/' + resourceName);
        command.arg(`--replicas=${replicas}`);
        return this.execute(command);
    }
    patch(resourceType, resourceName, patch, strategy) {
        const command = tl.tool(this.kubectlPath);
        command.arg('patch');
        command.arg([resourceType, resourceName]);
        command.arg(`--type=${strategy}`);
        command.arg([`-p`, patch]);
        return this.execute(command);
    }
    delete(args) {
        const command = tl.tool(this.kubectlPath);
        command.arg('delete');
        command.line(args);
        return this.execute(command);
    }
    execute(command, silent) {
        if (this.ignoreSSLErrors) {
            command.arg('--insecure-skip-tls-verify');
        }
        command.arg(['--namespace', this.namespace]);
        return command.execSync({ silent: !!silent });
    }
    createInlineArray(str) {
        if (typeof str === 'string') {
            return str;
        }
        return str.join(',');
    }
    deleteSecret(secretName) {
        const command = tl.tool(this.kubectlPath);
        command.arg('delete');
        command.arg('secret');
        command.arg(secretName);
        this.execute(command);
    }
}
exports.Kubectl = Kubectl;
